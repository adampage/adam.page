{% set scene = artwork.pixelScenes.scenes.myFace %}
{% set maps = artwork.pixelScenes.helpers.mapUniqueSceneColors(scene) %}
{# {% set spriteMatrices = artwork.pixelScenes.helpers.getSpriteMatrices(scene) %} #}
{% set dictByToken = maps[0] %}
{% set dictByColor = maps[1] %}
{% set pixelSize = scene.info.pixelSize %}
{% set width = scene.info.stage.width * pixelSize %}
{% set height = scene.info.stage.height * pixelSize %}

{# <!-- TODO: Generate initial frame as static SVG and pass to dist. --> #}
{# <!-- TODO: Or commit all frames as static SVGs and generate matrices? --> #}

<figure class="[ pixel-scene ] [ when-js ]">
  <noscript>
    {# <!-- TODO: Serve pixel scene as static svg via img element. --> #}
  </noscript>
</figure>

<script>
  const {% for token, colorValue in dictByToken %}
    {{ token }}="{{ colorValue }}"{% if not loop.last %},{% endif %}
  {%- endfor -%};
  const xmlns = 'http://www.w3.org/2000/svg';
  const pixelScene = document.querySelector('.pixel-scene');
  const pSize = {{ pixelSize }};

  // Create svg element.
  let svgElem = document.createElementNS(xmlns, "svg");
  let svgChildren = [];
  svgElem.setAttributeNS(null, 'width', '{{ width }}');
  svgElem.setAttributeNS(null, 'height', '{{ height }}');
  svgElem.setAttributeNS(null, 'viewbox', '0 0 {{ width }} {{ height }}');
  svgElem.setAttributeNS(null, 'shape-rendering', 'crispEdges');

  // Create svg’s title element.
  let titleElem = document.createElementNS(xmlns, "title");
  titleElem.textContent = '{{ scene.info.name }}';
  svgChildren.push(titleElem);

  // Create empty dictionary for sprites
  let sprites = {};

  // Collect sprite data.
  {%- for slugSprite, sprite in scene.sprites -%}

    {% set initialFrame = sprite.frames[sprite.info.initialFrame] %}

    sprites['{{slugSprite}}'] = {};

    sprites['{{slugSprite}}'].info = {{ sprite.info | dump | safe }};


    // TODO: non-opaque, non-animating pixels should be converted to null in
    // matrix and forego <rect> generation.
    sprites['{{slugSprite}}'].initialFrame = {
      "name": "{{ initialFrame.name }}",

      // "spriteMatrix": [
      //   {%- for row in spriteMatrix %}
      //     [ {% for pixelToken in row %}{{ pixelToken }}{% if not loop.last %},{% endif %}{% endfor %} ]{% if not loop.last %},{% endif %}
      //   {%- endfor %}
      // ]

      "matrix": [
        {%- for row in initialFrame.colorMatrix %}
          [ {% for colorValue in row %}{{ dictByColor[colorValue] }}{% if not loop.last %},{% endif %}{% endfor %} ]{% if not loop.last %},{% endif %}
        {%- endfor %}
      ]
    };
  {%- endfor %}

  Object.entries(sprites).forEach(([slugSprite, sprite]) => {

    sprite.initialFrame.matrix.forEach((row, y) => {

      // Create an svg group element to contain a row of sprite pixels.
      let rowElem = document.createElementNS(xmlns, "g");
      rowElem.classList.add('row');

      row.forEach((token, x) => {

        // Calculate pixel’s position on the scene stage.
        let pX = (x + sprite.info.origin.x) * pSize;
        let pY = (y + sprite.info.origin.y) * pSize;

        // Create a rect element to represent a colored sprite pixel.
        let p = document.createElementNS(xmlns, "rect");
        p.setAttributeNS(null, 'fill', token);
        p.setAttributeNS(null, 'x', pX);
        p.setAttributeNS(null, 'y', pY);
        p.setAttributeNS(null, 'width', pSize);
        p.setAttributeNS(null, 'height', pSize);

        // Add this pixel to the row.
        rowElem.appendChild(p);
      });

      // Add row to svg children elements.
      svgChildren.push(rowElem);
    });

  });

  // Append svg’s children elements.
  svgChildren.forEach(child => {
    svgElem.appendChild(child);
  });

  // Append svg to pixel scene parent element.
  pixelScene.append(svgElem);

</script>
