{% set scene = artwork.pixelScenes.scenes.myFace %}
{% set maps = artwork.pixelScenes.helpers.mapUniqueSceneColors(scene) %}
{% set dictByToken = maps[0] %}
{% set dictByColor = maps[1] %}
{% set pixelSize = scene.info.pixelSize %}
{% set width = scene.info.stage.width * pixelSize %}
{% set height = scene.info.stage.height * pixelSize %}

{# <!-- TODO: Generate initial frame as static SVG and pass to dist. --> #}
{# <!-- TODO: Or commit all frames as static SVGs and generate matrices? --> #}

<figure class="[ pixel-scene ] [ when-js ]">
  <noscript>
    {# <!-- TODO: Serve pixel scene as static svg via img element. --> #}
  </noscript>
</figure>

<script>
  const {% for token, colorValue in dictByToken -%}
    {{ token }}="{{ colorValue }}"{% if not loop.last %},{% endif %}
  {%- endfor -%};
  const xmlns = 'http://www.w3.org/2000/svg';
  const pixelScene = document.querySelector('.pixel-scene');
  const pSize = {{ pixelSize }};

  // Create svg element.
  let svgElem = document.createElementNS(xmlns, "svg");
  let svgChildren = [];
  svgElem.setAttributeNS(null, 'width', '{{ width }}');
  svgElem.setAttributeNS(null, 'height', '{{ height }}');
  svgElem.setAttributeNS(null, 'viewbox', '0 0 {{ width }} {{ height }}');
  svgElem.setAttributeNS(null, 'shape-rendering', 'crispEdges');

  // Create svg’s title element.
  let titleElem = document.createElementNS(xmlns, "title");
  titleElem.textContent = '{{ scene.info.name }}';
  svgChildren.push(titleElem);

  // Process scene sprites.
  let sprite = { info: {}, initialFrame: {}};

  {%- for slugSprite, sprite in scene.sprites -%}
    {%- set initialFrame = sprite.frames[sprite.info.initialFrame] %}

    sprite.info = {{ sprite.info | dump | safe }};

    // TODO: non-opaque, non-animating pixels should be converted to null in
    // matrix and forego <rect> generation.
    sprite.initialFrame = {
      "name": "{{ initialFrame.name }}",
      "matrix": [
        {%- for row in initialFrame.matrix %}
          [ {% for colorValue in row %}{{ dictByColor[colorValue] }}{% if not loop.last %},{% endif %}{% endfor %} ]{% if not loop.last %},{% endif %}
        {%- endfor %}
      ]
    };

    sprite.initialFrame.matrix.forEach((row, y) => {

      // Create an svg group element to contain a row of sprite pixels.
      let rowElem = document.createElementNS(xmlns, "g");
      rowElem.classList.add('row');

      row.forEach((token, x) => {

        // Calculate pixel’s position on the scene stage.
        let pX = (x + sprite.info.origin.x) * pSize;
        let pY = (y + sprite.info.origin.y) * pSize;

        // Create a rect element to represent a colored sprite pixel.
        let p = document.createElementNS(xmlns, "rect");
        p.setAttributeNS(null, 'fill', token);
        p.setAttributeNS(null, 'x', pX);
        p.setAttributeNS(null, 'y', pY);
        p.setAttributeNS(null, 'width', pSize);
        p.setAttributeNS(null, 'height', pSize);

        // Add this pixel to the row.
        rowElem.appendChild(p);
      });

      // Add row to svg children elements.
      svgChildren.push(rowElem);
    });

  {%- endfor %}

  // Append svg’s children elements.
  svgChildren.forEach(child => {
    svgElem.appendChild(child);
  });

  // Append svg to pixel scene parent element.
  pixelScene.append(svgElem);

</script>
